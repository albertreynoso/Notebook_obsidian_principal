#notas 
### El Flujo Correcto de Cambios

La clave es **nunca** hacer `git pull` directamente sobre cambios no confirmados (uncommitted), ya que eso podría crear conflictos difíciles de manejar. En su lugar, sigue este flujo:

1. **Guarda tu trabajo en un estante temporal (Stash):**  
    Este comando guarda tus cambios modificados (en el working directory) y el staging area en una pila temporal, dejando tu directorio de trabajo limpio.
    
    bash
    
    git stash push -m "Mi trabajo en progreso antes de traer los cambios nuevos"
    
    `-m` añade un mensaje descriptivo para saber qué hay en este stash.
    
2. **Trae los cambios nuevos de tu compañero:**  
    Ahora que tu directorio está "limpio", puedes traer los cambios del remoto e integrarlos sin problemas.
    
    bash
    
    git pull origin main  # o 'master', o el nombre de tu rama
    
3. **Recupera tu trabajo del estante:**  
    Ahora aplica los cambios que habías guardado temporalmente sobre la base ya actualizada con el trabajo de tu compañero.
    
    bash
    
    git stash pop
    
4. **Resuelve Conflictos (si los hay):**  
    El comando `pop` intentará fusionar automáticamente tus cambios con los nuevos. Si tú y tu compañero modificaron las mismas líneas en los mismos archivos, Git te avisará de un **conflicto**.
    
    - **Cómo se ve:** Los archivos conflictivos tendrán marcas especiales:
        
        bash
        
        <<<<<<< Updated upstream
        // El código que vino del repositorio remoto (de tu compañero)
        =======
        // Tu código que estaba en el stash
        >>>>>>> Stashed changes
        
    - **Cómo solucionarlo:** Abre esos archivos en tu editor, decide qué código conservar (o combina ambos manualmente), elimina las marcas `<<<<<<<`, `=======`, `>>>>>>>` y guarda el archivo.
        
5. **Finaliza el proceso:**  
    Una vez resueltos los conflictos (si los hubo), añade los archivos resueltos y haz commit.
    
    bash
    
    git add nombre_del_archivo_conflictivo.js
    git commit -m "Combinando mi trabajo con los cambios del remoto"
    
6. **Ahora sí, sube tus cambios:**
    
    bash
    
    git push origin main


### Resumen de funcionamiento de Git
Aquí tienes una tabla de conceptos fundamentales de Git, organizados por categorías, con sus definiciones y ejemplos prácticos, basada en los materiales proporcionados:

| Categoría                                     | Concepto                                                                 | Definición                                                                                                                                                                                                                                                                                                                                                   | Ejemplo Práctico                                                                                                                                                                                       |
| :-------------------------------------------- | :----------------------------------------------------------------------- | :----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | :----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| **I. Fundamentos y Arquitectura de Git**      |                                                                          |                                                                                                                                                                                                                                                                                                                                                              |                                                                                                                                                                                                        |
| Fundamentos de Git                            | **Git (Sistema de Control de Versiones Distribuido - DVCS)**             | Es un popular y ampliamente utilizado sistema de gestión de código fuente que simplifica el ciclo de desarrollo. Permite a los usuarios crear, usar y cambiar entre ramas fácilmente, implementado con una arquitectura rápida y eficiente que facilita la experimentación y el refinamiento de cambios locales en un entorno aislado antes de compartirlos. | Para iniciar un nuevo repositorio Git en un directorio, se utiliza `git init`.                                                                                                                         |
| Arquitectura Interna                          | **Repositorio Local (Local Repository)**                                 | La copia del repositorio que reside en la máquina del usuario. Contiene todos los objetos y la historia del proyecto. Junto con el *staging area* y el *working directory*, forma el *local environment*.                                                                                                                                                    | El archivo `.git/config` dentro del directorio de tu proyecto contiene la configuración local específica de ese repositorio.                                                                           |
| Arquitectura Interna                          | **Directorio de Trabajo (Working Directory)**                            | Es el área en tu sistema de archivos donde se encuentran los archivos visibles del proyecto. Aquí es donde creas, editas y eliminas contenido antes de que Git comience a rastrearlo.                                                                                                                                                                        | Para crear un directorio de trabajo y navegar a él, usarías `mkdir grocery` seguido de `cd grocery/`.                                                                                                  |
| Arquitectura Interna                          | **Staging Area (Área de Preparación/Índice/Caché)**                      | Un nivel intermedio entre el directorio de trabajo y el repositorio local. Sirve como un área de retención para acumular y preparar cambios antes de que se realicen commits en el repositorio local, permitiendo un control granular sobre qué cambios se incluirán en el próximo commit.                                                                   | `git add .` añade todos los archivos nuevos o modificados del directorio de trabajo al staging area.                                                                                                   |
| Arquitectura Interna                          | **Commit**                                                               | En Git, un "commit" es tanto la acción de guardar los cambios del *staging area* en el repositorio local, como la entidad (un snapshot de un árbol de directorios) que representa un punto específico en la historia del proyecto. Cada commit tiene un identificador único SHA1.                                                                            | `git commit -m "Add a banana to the shopping list"` crea un nuevo commit con un mensaje descriptivo.                                                                                                   |
| Arquitectura Interna                          | **SHA1 (Secure Hash Algorithm 1)**                                       | Un valor de hash criptográfico que Git calcula para cada objeto (blob, tree, commit) para identificarlo de forma única. Generalmente se utilizan los primeros siete caracteres para referenciar un commit.                                                                                                                                                   | La salida de `git log --oneline` muestra los SHA1 abreviados de los commits, como `4142ad9 Add the other half of the grape`.                                                                           |
| Arquitectura Interna                          | **HEAD**                                                                 | Un puntero o referencia al commit más reciente en la rama actual. Indica la rama activa o el commit específico en el que te encuentras. Si `HEAD` apunta directamente a un commit y no a una rama, se dice que está en estado "detached HEAD".                                                                                                               | En el `git log` se muestra `(HEAD -> master)` para indicar que HEAD apunta a la rama `master`. Para mover HEAD al commit anterior, se usa `git reset --hard HEAD^`.                                    |
| Arquitectura Interna                          | **Objetos Git (Git Objects)**                                            | Git utiliza cuatro tipos fundamentales de objetos para construir la historia del repositorio: **commits**, **trees**, **blobs** y **annotated tags**. Estos se almacenan en el subdirectorio `.git/objects`.                                                                                                                                                 | `git cat-file -p <hash>` permite inspeccionar el contenido de cualquier objeto Git usando su hash.                                                                                                     |
| Arquitectura Interna                          | **Blob (Binary Large Object)**                                           | Un contenedor anónimo que almacena el contenido de un archivo. No incluye el nombre del archivo, solo sus datos.                                                                                                                                                                                                                                             | En la salida de `git cat-file -p <tree-hash>`, verás líneas como `100644 blob 907b75b... README.md`, donde `907b75b...` es el hash del blob para `README.md`.                                          |
| Arquitectura Interna                          | **Tree (Objeto Árbol)**                                                  | Un contenedor que organiza blobs (archivos) y otros trees (subdirectorios), representando la estructura de directorios en un punto específico del historial.                                                                                                                                                                                                 | Un commit apunta a un objeto tree, como se ve en `tree a31c31c...` en la salida de `git cat-file -p <commit-hash>`.                                                                                    |
| Arquitectura Interna                          | **Comandos Porcelain (Porcelain Commands)**                              | Comandos Git de alto nivel y más fáciles de usar, diseñados para las operaciones comunes del usuario. Son más estables en su interfaz a lo largo del tiempo.                                                                                                                                                                                                 | `git add`, `git commit`, `git merge` son ejemplos de comandos porcelain.                                                                                                                               |
| Arquitectura Interna                          | **Comandos Plumbing (Plumbing Commands)**                                | Comandos Git de bajo nivel que operan directamente sobre los objetos del repositorio. No están destinados al uso diario del usuario promedio, sino para manipulaciones internas o scripts avanzados.                                                                                                                                                         | `git cat-file` es un comando plumbing usado para inspeccionar el contenido de los objetos Git.                                                                                                         |
| **II. Gestión del Historial y Ramas**         |                                                                          |                                                                                                                                                                                                                                                                                                                                                              |                                                                                                                                                                                                        |
| Ramas                                         | **Rama (Branch)**                                                        | Una rama es una etiqueta móvil que apunta al último commit en una secuencia de trabajo. Las ramas en Git son muy ligeras y fáciles de crear, eliminar y manipular, a diferencia de los sistemas de control de versiones tradicionales.                                                                                                                       | `git branch new-feature` crea una nueva rama llamada `new-feature` que apunta al commit actual.                                                                                                        |
| Ramas                                         | **`git checkout`**                                                       | Comando utilizado para cambiar entre ramas, restaurar archivos del directorio de trabajo a una versión específica o mover `HEAD` a un commit particular.                                                                                                                                                                                                     | `git checkout master` cambia a la rama `master`. `git checkout -- file.txt` descarta los cambios locales en `file.txt`.                                                                                |
| Ramas                                         | **`git reset`**                                                          | Comando para deshacer cambios, moviendo el puntero de la rama (`HEAD`) a un commit anterior. Puede afectar el *staging area* y el *working directory* de diferentes maneras, dependiendo de las opciones (`--soft`, `--mixed`, `--hard`).                                                                                                                    | `git reset --hard HEAD^` mueve la rama actual un commit hacia atrás y descarta todos los cambios en el *staging area* y *working directory*.                                                           |
| Ramas                                         | **`git merge`**                                                          | Comando para integrar los cambios de una rama a otra. Combina las historias de desarrollo. Puede ser una "fast-forward merge" (si no hay divergencia) o una "three-way merge" (si hay conflictos o divergencia en el historial).                                                                                                                             | `git merge melons` fusiona los cambios de la rama `melons` en la rama actual.                                                                                                                          |
| Ramas                                         | **`git rebase`**                                                         | Comando para reescribir el historial de commits, aplicando una secuencia de commits de una rama sobre otra base. Mueve la "base" de tu rama a un nuevo commit.                                                                                                                                                                                               | `git rebase -i HEAD~2` inicia una rebase interactiva para modificar los dos últimos commits. `git rebase master` rebasea la rama actual sobre `master`.                                                |
| Ramas                                         | **`git cherry-pick`**                                                    | Comando para aplicar un commit específico de una rama a la rama actual, sin fusionar toda la rama. Es una operación más selectiva que `merge` o `rebase`.                                                                                                                                                                                                    | `git cherry-pick ef6c382` aplica el commit con el hash `ef6c382` a la rama actual.                                                                                                                     |
| Historial                                     | **Tags (Etiquetas)**                                                     | Nombres simbólicos fijos que se adjuntan a un commit específico. A diferencia de las ramas, las etiquetas no se mueven con los nuevos commits y se utilizan para marcar puntos importantes en el historial, como versiones de lanzamiento. Existen "simple tags" y "annotated tags".                                                                         | `git tag v1.0` crea una etiqueta simple `v1.0` en el commit actual. `git tag -a v1.0 -m "Release version 1.0"` crea una etiqueta anotada.                                                              |
| **III. Colaboración y Repositorios Remotos**  |                                                                          |                                                                                                                                                                                                                                                                                                                                                              |                                                                                                                                                                                                        |
| Repositorios Remotos                          | **Repositorio Remoto (Remote Repository)**                               | Una copia del repositorio Git alojada en un servidor o en otra ubicación, utilizada para compartir y sincronizar el trabajo entre varios desarrolladores. Sirve como punto central para la colaboración.                                                                                                                                                     | Un repositorio en GitHub, como `https://github.com/fsantacroce/Cookbook.git`, es un repositorio remoto.                                                                                                |
| Repositorios Remotos                          | **`git clone`**                                                          | Comando utilizado para crear una copia local completa de un repositorio remoto existente, incluyendo todos sus archivos, ramas e historial.                                                                                                                                                                                                                  | `git clone https://github.com/fsantacroce/Cookbook.git` clona el repositorio `Cookbook` a tu máquina local.                                                                                            |
| Repositorios Remotos                          | **Origin**                                                               | El nombre predeterminado que Git asigna automáticamente al repositorio remoto del cual se clonó un proyecto. Es una convención, aunque los remotos pueden tener cualquier nombre.                                                                                                                                                                            | `git remote -v` muestra la URL asociada al remoto `origin`.                                                                                                                                            |
| Repositorios Remotos                          | **`git fetch`**                                                          | Comando que descarga los objetos y referencias de un repositorio remoto al repositorio local, pero no los fusiona automáticamente con tus ramas de trabajo locales. Actualiza las "ramas de seguimiento remoto".                                                                                                                                             | `git fetch origin` descarga los cambios más recientes del remoto llamado `origin`.                                                                                                                     |
| Repositorios Remotos                          | **`git pull`**                                                           | Comando que es una combinación de `git fetch` y `git merge`. Descarga los cambios del repositorio remoto y luego los fusiona automáticamente en la rama local actual.                                                                                                                                                                                        | `git pull origin master` descarga y fusiona los cambios de la rama `master` del remoto `origin` en tu rama `master` local.                                                                             |
| Repositorios Remotos                          | **`git push`**                                                           | Comando que carga los commits desde tu repositorio local a un repositorio remoto. Es la forma de compartir tus cambios con el equipo.                                                                                                                                                                                                                        | `git push -u origin master` envía tus commits de la rama `master` local al remoto `origin`.                                                                                                            |
| Colaboración                                  | **Fork (Bifurcación)**                                                   | Una copia personal de un repositorio de otro usuario o proyecto en un sitio de alojamiento como GitHub. Permite a los usuarios experimentar o realizar cambios sin afectar el proyecto original.                                                                                                                                                             | Al hacer clic en el botón "Fork" en la página de un repositorio como `octocat/Spoon-Knife`, se crea una copia del proyecto en tu cuenta de GitHub.                                                     |
| Colaboración                                  | **Pull Request (Solicitud de Extracción)**                               | Un mecanismo para proponer cambios de una rama o repositorio bifurcado al repositorio original (upstream). Permite la revisión de código y la discusión antes de que los cambios sean fusionados por los mantenedores del proyecto.                                                                                                                          | Después de realizar cambios en un *fork* y empujarlos, GitHub muestra un botón "New pull request" para iniciar el proceso de propuesta.                                                                |
| **IV. Flujos de Trabajo Comunes**             |                                                                          |                                                                                                                                                                                                                                                                                                                                                              |                                                                                                                                                                                                        |
| Estrategias de Desarrollo                     | **Flujo de Trabajo Centralizado (Centralized Workflow)**                 | Un enfoque simple donde los desarrolladores trabajan principalmente en una única rama (`master` o `trunk`), y todos los cambios se fusionan directamente en ella.                                                                                                                                                                                            | Un equipo de desarrollo donde todos los miembros hacen commits y fusiones directamente a la rama `master`.                                                                                             |
| Estrategias de Desarrollo                     | **Flujo de Trabajo de Rama de Característica (Feature Branch Workflow)** | Los desarrolladores crean una rama separada para cada nueva característica o tarea. Los cambios se desarrollan en esta rama aislada y se fusionan de nuevo a la rama principal (ej. `develop` o `master`) una vez completados.                                                                                                                               | Crear la rama `git branch feature/new-login-design`, desarrollar la funcionalidad y luego fusionarla de nuevo a `develop` o `master`.                                                                  |
| Estrategias de Desarrollo                     | **Gitflow**                                                              | Un modelo de ramificación y fusión más estructurado que define ramas específicas para distintas etapas del desarrollo: `master` (producción), `develop` (desarrollo), `feature/*` (nuevas características), `release/*` (preparación de lanzamientos) y `hotfix/*` (corrección de errores críticos).                                                         | Un proyecto que utiliza una rama `develop` para integrar el trabajo de `feature` branches y ramas `release` para preparar nuevas versiones.                                                            |
| Estrategias de Desarrollo                     | **GitHub Flow**                                                          | Un flujo de trabajo más ligero que Gitflow, centrado en que la rama `master` sea siempre desplegable. Las características se desarrollan en ramas descriptivas a partir de `master`, se empujan, se abren *Pull Requests* para revisión y se despliegan inmediatamente después de la aprobación.                                                             | Un desarrollador crea una rama `descriptive-branch-name` a partir de `master`, hace sus commits, abre un Pull Request en GitHub, y una vez aprobado, se fusiona a `master` y se despliega.             |
| Estrategias de Desarrollo                     | **Desarrollo Basado en Troncal (Trunk-based Development)**               | Estrategia que prioriza una única rama principal (`master` o `trunk`) a la que los desarrolladores realizan commits pequeños y frecuentes. Su objetivo es la integración continua y evitar ramas de larga duración.                                                                                                                                          | Todos los desarrolladores trabajan en `master`, comprometiendo cambios pequeños y frecuentes, usando *feature flags* para esconder características incompletas.                                        |
| Estrategias de Desarrollo                     | **Flujo de Trabajo del Kernel de Linux (Linux Kernel Workflow)**         | Un flujo de trabajo jerárquico donde los desarrolladores individuales trabajan en sus ramas, las envían a "tenientes" (desarrolladores de área), quienes a su vez las remiten a Linus Torvalds, y finalmente él las integra en el repositorio principal.                                                                                                     | Un desarrollador que envía un parche a un "teniente" para su revisión, quien luego lo puede reenviar a Linus Torvalds para su inclusión final en el kernel.                                            |
| **V. Configuración y Herramientas Avanzadas** |                                                                          |                                                                                                                                                                                                                                                                                                                                                              |                                                                                                                                                                                                        |
| Configuración                                 | **Alias de Git (Git Aliases)**                                           | Atajos personalizados para comandos de Git que se configuran globalmente o por repositorio. Permiten simplificar comandos largos o crear "nuevos comandos" con opciones preestablecidas.                                                                                                                                                                     | `git config --global alias.co checkout` crea el alias `co` para `git checkout`. `git config --global alias.unstage 'reset HEAD --'` crea el comando `git unstage`.                                     |
| Herramientas Avanzadas                        | **`git stash`**                                                          | Guarda temporalmente los cambios en el directorio de trabajo y el área de preparación que no están listos para un commit, permitiendo cambiar de rama o realizar otras operaciones sin perder el trabajo. Los cambios se pueden reaplicar más tarde.                                                                                                         | `git stash` guarda tus cambios sin comitear y limpia tu directorio de trabajo y *staging area*.                                                                                                        |
| Herramientas Avanzadas                        | **`git blame`**                                                          | Muestra el historial de revisiones línea por línea de un archivo, indicando el autor del último cambio, la fecha y el SHA1 del commit para cada línea.                                                                                                                                                                                                       | `git blame README.md` muestra quién modificó cada línea del archivo `README.md` y cuándo.                                                                                                              |
| Configuración                                 | **`git attributes` (Archivo de Atributos de Git)**                       | Un archivo que permite especificar cómo Git debe manejar ciertos tipos de archivos o patrones, como identificarlos como binarios, definir terminaciones de línea (`EOL`) o aplicar filtros personalizados (`smudge/clean`).                                                                                                                                  | En un archivo `.gitattributes`, la línea `*.exe binary` le dice a Git que trate todos los archivos `.exe` como binarios. `*.txt eol=crlf` fuerza las terminaciones de línea CRLF para archivos `.txt`. |
| Configuración                                 | **`git ignore` (Archivo Ignore de Git)**                                 | Un archivo que lista patrones de nombres de archivos y directorios que Git debe ignorar y no rastrear en el repositorio. Es útil para excluir archivos generados automáticamente, archivos temporales o de configuración específicos del usuario.                                                                                                            | Crear un archivo `.gitignore` con la entrada `*.log` instruye a Git a ignorar todos los archivos con extensión `.log`.                                                                                 |
| Configuración                                 | **Hooks de Git (Git Hooks)**                                             | Scripts o programas que se ejecutan automáticamente antes o después de ciertos eventos de Git (por ejemplo, antes de un commit, después de un merge o un push). Permiten automatizar tareas y hacer cumplir políticas.                                                                                                                                       | Un *pre-commit hook* puede ejecutar pruebas unitarias para asegurar que solo se hagan commits con código funcional.                                                                                    |
| Herramientas Avanzadas                        | **`git bisect`**                                                         | Implementa una búsqueda binaria automatizada a través del historial de commits para identificar rápidamente el commit exacto donde se introdujo un bug o un cambio específico.                                                                                                                                                                               | Para encontrar el commit que introdujo un error, se usarían los comandos `git bisect start`, `git bisect bad <commit_con_error>`, `git bisect good <commit_sin_error>`.                                |
| Herramientas Avanzadas                        | **`git rerere` (Reuse Recorded Resolution)**                             | Permite a Git recordar cómo resolviste manualmente un conflicto de fusión en particular. Si el mismo conflicto se encuentra de nuevo en el futuro, Git intentará aplicar automáticamente la resolución guardada.                                                                                                                                             | Después de resolver un conflicto complejo, `git rerere` puede configurarse para recordar la solución y aplicarla automáticamente si el conflicto reaparece en un merge o rebase futuro.                |
| Herramientas Avanzadas                        | **`git worktree`**                                                       | Permite crear múltiples directorios de trabajo, cada uno asociado a una rama diferente, pero todos conectados a un único repositorio local. Esto te permite trabajar en varias ramas simultáneamente sin necesidad de clonar el repositorio varias veces o de hacer `git stash` constantemente.                                                              | `git worktree add -b features ../super_calc_features origin/features` crea un nuevo directorio (`super_calc_features`) para trabajar en la rama `features`.                                            |
| Herramientas Avanzadas                        | **Submódulos (Submodules)**                                              | Una forma de incluir un repositorio Git separado como un subdirectorio dentro de otro repositorio (conocido como *superproject*). El *superproject* registra un commit específico del submódulo, lo que es útil para gestionar dependencias de proyectos.                                                                                                    | `git submodule add https://github.com/usuario/dependency_repo sub_dir` añade `dependency_repo` como un submódulo en `sub_dir`.                                                                         |
| Herramientas Avanzadas                        | **Subárboles (Subtrees)**                                                | Una alternativa a los submódulos para integrar un repositorio externo como un subdirectorio. A diferencia de los submódulos, el historial del subárbol se fusiona y se convierte en parte del historial del repositorio principal, lo que simplifica la gestión de las operaciones.                                                                          | `git subtree add -P sub_docs --squash https://github.com/usuario/docs_repo master` añade el repositorio `docs_repo` como un subárbol en la carpeta `sub_docs`.                                         |

Espero que esta tabla te sea de gran utilidad para comprender los conceptos fundamentales de Git.

### Contenido adicional
Pagina para aprender git interactivamente
https://learngitbranching.js.org/


### contenido adicional 2
